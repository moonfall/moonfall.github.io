<html>
<head>
  <title>Memory workload test</title>
</head>
<body>
  <h1>Memory workload test</h1>
  <label for="loadtime">Load time</label>
  <input id="loadtime" size="64" readonly /><br />
  <label for="lasttime">Last time</label>
  <input id="lasttime" size="64" readonly /><br />
  <pre id="lifePre"></pre>
  <label for="blocksize">Block size (MiB)</label>
  <input id="blocksize" type="number" value="128" /><br />
  <label for="total">Total allocated</label>
  <input id="totalslider" type="range" min="0" max="4096" step="128"/>
  <input id="totalnum" type="number" min="0" max="4096" step="128"/><br />
  <button id="alloc">Allocate memory</button>
  <button id="free">Free all memory</button>
  <button id="update">Update status</button>

  <pre id="statusPre"></pre>
  <pre id="allocPre"></pre>
</body>

<script>
  // Track when the script is initially loaded in case it gets reloaded.
  var startTime;
  // Total number of allocations performed.
  var allocCount = 0;
  // Array of ArrayBuffer allocations.
  var allocated = [];

  // Button handlers.
  alloc.onclick = () => {
    allocOnce();
  }
  free.onclick = () => {
    show("Free all clicked");
    allocated = [];
    updateStatus();
  }
  update.onclick = () => {
    show("Update clicked");
    updateStatus();
  }
  totalslider.onchange = () => {
    show("Set clicked");
    totalnum.value = totalslider.value;
    setAllocatedMemory(totalslider.value);
  }
  totalslider.oninput = () => {
    // Update the numeric value in real time.
    totalnum.value = totalslider.value;
  }

  totalnum.oninput = () => {
    // Update the numeric value in real time.
    show("Set value");
    totalslider.value = totalnum.value;
    setAllocatedMemory(totalnum.value);
  }

  function currentAllocatedMiB() {
    let total = 0;
    for (let i = 0; i < allocated.length; ++i) {
      total += allocated[i].byteLength;
    }
    return total / (1024 * 1024);
  }

  function setAllocatedMemory(target) {
    let frees = 0;
    while (currentAllocatedMiB() > target) {
      allocated.pop();
      ++frees;
      updateStatus();
    }
    let allocs = 0;
    while (currentAllocatedMiB() < target) {
      let sizeMiB = Math.min(target - currentAllocatedMiB(), blocksize.value);
      allocBuffer(sizeMiB * 1024 * 1024);
      ++allocs;
      updateStatus();
    }
    show(frees + " blocks freed; " + allocs + " blocks allocated");
  }

  // Update the current status of the page.
  function updateStatus() {
    const now = new Date();
    lasttime.value = now.toString();
    const elapsed = now - startTime;
    lifePre.textContent = (elapsed / 1000) + " seconds";

    let total = currentAllocatedMiB();
    allocPre.textContent = total + " MiB;  " + allocated.length + " blocks";

    totalslider.value = total;
    totalnum.value = total;
  }

  // Allocate and fill a single block.
  function allocOnce() {
    ++allocCount;
    show("Allocate called " + allocCount);
    allocBuffer(blocksize.value * 1024 * 1024);
    updateStatus();
  }

  // Allocate and fill a buffer of a given size.
  function allocBuffer(size) {
    buffer = new ArrayBuffer(size);
    allocated.push(buffer);
    fillBuffer(buffer);
  }

  // Fill a buffer with random data.
  function fillBuffer(buffer) {
    // console.log("Filling " + buffer);
    // Crypto.getRandomValues can generate up to 64KiB at a time.
    const maxBlockSize = 64 * 1024;
    for (let i = 0; i < buffer.byteLength; i += maxBlockSize) {
      const bytesRemaining = buffer.byteLength - i;
      const viewSize = Math.min(bytesRemaining, maxBlockSize);
      const view = new Int8Array(buffer, i, viewSize);
      crypto.getRandomValues(view);
    }
  }

  // Show and log a status line.
  function show(s) {
    console.log(s);
    statusPre.textContent = s;
  }

  // Function that is called once when the script is initially loaded.
  function startup() {
    // Track when the page was initially loaded.
    startTime = new Date();
    show("Startup called " + startTime);
    loadtime.value = startTime.toString();

    // Handle URL params.
    const params = new URLSearchParams(window.location.search);
    if (params.has("blocksize")) {
      blocksize.value = params.get("blocksize");
    }
    if (params.has("alloc")) {
      // Perform allocations.
      for (let i = 0; i < params.get("alloc"); ++i) {
        allocOnce();
      }
    }

    updateStatus();
  }

  startup();
</script>
</html>
